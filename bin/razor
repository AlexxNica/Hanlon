#!/usr/bin/env ruby
#
# CLI Control for ProjectRazor
# Format will be 'project_razor [module namespace] [module args{}]'
#

# We first add our Lib path to the load path. This is for non-gem ease of use
lib_path = File.dirname(File.expand_path(__FILE__)).sub(/\/bin$/,"/lib")
$LOAD_PATH.unshift(lib_path)


require 'rubygems' if RUBY_VERSION < '1.9'
# We require the root lib
require "project_razor"

# We need these for misc operations later
require "json"
require "colored"
require "optparse"

# We set a constant for our Slice root Namespace. We use this to pull the slice names back out
# from objectspace
SLICE_PREFIX = "ProjectRazor::Slice::"

def file2const(filename)
  filename.to_s.split('_').map(&:capitalize).join
end

#
def init
  @obj = ProjectRazor::Object.new
  @version = @obj.get_razor_version
  @logger = @obj.get_logger
  get_slices_loaded
end

def call_razor_slice(raw_name, args)
  return nil if raw_name.nil?

  name = file2const(raw_name)
  razor_module = Object.full_const_get(SLICE_PREFIX + name).new(args)
  razor_module.web_command = @web_command
  razor_module.verbose = @verbose
  razor_module.debug = @debug
  razor_module.slice_call
  return true
rescue => e
  unless e.to_s =~ /uninitialized constant ProjectRazor::Slice::/
    @logger.error "Razor slice error: #{e.message}"
    print "\n [#{raw_name}] ".red
    print "<- #{e.message} \n".yellow
  end
  raise exception if @debug
  return false
end

# Load slices
def get_slices_loaded
  slice_path = File.expand_path(File.join(File.dirname(__FILE__), "..", "lib/project_razor/slice/*.rb"))

  @slice_array = []
  Dir.glob(slice_path) do |f|
    @slice_array << file2const(File.basename(f,File.extname(f)))
  end

end

def print_loaded_slices
  print "\nLoaded slices:\n\t"
  x = 1
  @slice_array.sort.each do |slice|
    slice_obj = ::Object.full_const_get(SLICE_PREFIX + slice).new([])
    unless slice_obj.hidden
      print "[#{slice.downcase}] ".white
      if x > 5
        print "\n\t"
        x = 0
      end
      x += 1
    end
  end
  print "\n"
end

def get_optparse

  OptionParser.new do |opts|
    opts.banner = "\n" + "Razor - #{@version}".bold.green
    opts.separator "Usage: "
    opts.separator "razor [slice name] [command argument] [command argument]...".red
    opts.separator ""
    opts.separator "Switches".yellow

    @options[:verbose] = false
    opts.on( '-v', '--verbose', 'Enables verbose object printing'.yellow ) do
      @options[:verbose] = true
    end

    @options[:debug] = false
    opts.on( '-d', '--debug', 'Enables printing proper Ruby stacktrace'.yellow ) do
      @options[:debug] = true
    end

    @options[:webcommand] = false
    opts.on( '-w', '--webcommand', 'Accepts web commands.'.yellow ) do
      @options[:webcommand] = true
    end

    @options[:nocolor] = false
    opts.on( '-n', '--no-color', 'Disables console color. Useful for script wrapping.'.yellow ) do
      @options[:nocolor] = true
    end

    opts.on_tail( '-h', '--help', 'Display this screen'.yellow ) do
      puts opts
      print_loaded_slices
      exit
    end
  end
end

def get_first_args
  f = []
  ARGV.each do |a|
    if a.start_with?("-")
      f << a
    else
      return f
    end
  end
  f
end

# Initialise some values
init
first_args = get_first_args
first_args.size.times {ARGV.shift}
@options = {}
optparse = get_optparse
begin
  optparse.parse(first_args)
rescue OptionParser::InvalidOption => e
  # We may use this option later so we will continue
  #puts e.message
  #puts optparse
  #exit
end

@web_command = @options[:webcommand]
@debug = @options[:debug]
@verbose = @options[:verbose]

if @options[:nocolor] or !STDOUT.tty?
  # if this flag is set, override the default behavior of the underlying "colorize" method
  # from the "Colored" module so that it just returns the string that was passed into it
  # (this will have the effect of turning off any color that might be included in any of
  # the output statements involving Strings in Razor)
  module Colored
    extend self
    def colorize(string, options = {})
      string
    end
  end
  String.send(:include, Colored)
  optparse = get_optparse # reload optparse with color disabled
end

slice = ARGV.shift
unless call_razor_slice(slice, ARGV)
  if @web_command
    puts JSON.dump({
        "slice"         => "ProjectRazor::Slice",
        "result"        => "InvalidSlice",
        "http_err_code" => 404
      })
  else
    puts optparse
    print_loaded_slices
    if slice
      print "\n [#{slice}] ".red
      print "<-Invalid Slice \n".yellow
    end
  end
end
